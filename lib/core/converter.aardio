
namespace core;

class converter {
    ctor(src, cfg) {
        var $_src = src;
        var $_config = {		//默认设置
            trimRight = true;	//是否清除末尾的空白符
            indentSpaces = 4;	//缩进空格数
            addSemicolon = true;//行尾添加分号
            camelize = true;	//变量名改为驼峰式
        };
        $_config = ..table.assign($_config, cfg);	//用参数覆盖设置
    }
    
    saveTo = function(src, fname) {
        //var now = ..time();
        //now.format = "%Y-%m-%d";// %H-%M-%S";
        fname = '/log/' ++ fname;
        //console.debug('converter.saveTo: filename='++fn);
        string.save(fname, src);
        return;
    }
    
    go = function(tag) {
        var result, err;
        var src = $_src;
        src = this.prepare(src);			//先进行多行并一行等准备工作
        //this.saveTo(src, tag++'.1.after_prepare.py');
        src = this.replaceByLines(src);		//再进行逐行性的替换
        //this.saveTo(src, tag++'.2.after_replaceByLines.py');
        src = this.replaceEntirety(src);	//最后进行整体性的替换
        //this.saveTo(src, tag++'.3.done.aardio');
        result = src;
        return result, err;
    }
    // 进行多行并一行等准备工作
    prepare = function(src) {
        var result = src;
        /*
        1. 写成多行的注释,列表[],元组(),字典{}和函数参数()
        */
        var patterns = {
        	`(<'''>|<""">)([\s\S]+?)(\1)`;	//以三个引号括住的多行注释
        	`([\(\[\{])\s(.*?[\r\n].*?)\s([\)\]\}])`; //写成多行的列表[],元组(),字典{}和函数参数()
        };
        for(n, ptn in patterns) {
        	// 将多行变成单行, 以防止被后续分割成多行参与到语法分析; 待处理结束后, 再转换回来
        	result = string.replace(result, ptn, function($1, $2, $3) {
            	//把多行注释内的回车换行(\x0D\x0A)替换为其它特殊字符: \x0a => \x1a
            	var str = $1 ++ string.replace($2, `\n`, '\x1a') ++ $3;
            	return str;
        	});
        }//for
       
        /*
        2. 写成多行的语句
        python中较长的语句如果一行写不完可以用反斜杠'\'来连接多行语句,
        而在(),{},[] 中则无需用反斜杠连接,
        //TODO: % 用来匹配两个对称的模式元及其位置区间内包含的字符串,例如'%()'匹配以`(′开始， 以 `)′结束的字符串,
        //而'%""'匹配以引号开始，以引号结束的字符串
		*/		
        patterns = {
        	`\\( *)[\r\n]+\s*`;			// 用单个反斜杠结尾的多行
        	`\s*([\,\+\/\(])[\r\n]+\s*`;	// 用小括号的多行, 第一行尾以'.,+-*/('之一结尾的
        	`\s*[\r\n]+\s*([\.\,\+\-\/\)])`;// 用小括号的多行, 第二行首以'.,+-*/)'之一开头的
        };
        for(n, ptn in patterns) {
        	result = string.replace(result, ptn, `\1`);
        }
        return result;
    }
    //判断是否空行
    isEmptyLine = function(line) {
        var result = false;
        // 去除行内的注释, 看看还有没有代码剩下
        var patterns = {
        	`\s*(<'''>|<""">)([\s\S]+?)(\1)`; // 多行注释(已预先转换成单行)
         	`\s*\/\/.*`;	// 单行注释 (已预先将注释符'#'替换为'//')
        };
        var line2 = line;
        for(n, ptn in patterns) {
            line2 = string.replace(line2, ptn, '');
        }

        //var line2 = string.replace(line, `\s*\/\/.*`, '');	
        line2 = string.trim(line2);		// 去掉首尾空格
        result = #line2 == 0;	// 若剩下长度为0, 说明是空行
        return result;
    }
    
    // 加/解密字符串字面量(加密是为了避免对字符串进行语法分析)
    encodeStrLiterals = function(line, encode=true) {
        var result = line;
        var x = encode ? 10 : -10;
        var pattern = `(['"])(.+?)(\1)`;
        // 逐个字符ASCII码加/减一个数值
		result = string.replace(result, pattern, function($1, $2, $3) {
			//console.debug('origin=' ++ $1++$2++$3);
			var $2a = {};
			for(i=1; #$2) {
				//var c = $2[i];	// c 是字符的值,即整数ASCII码
				$2a[i] = $2[i] + x;  // 按整数加法
			}
			var str = $1 ++ string.pack($2a) ++ $3;
			//console.debug('res=' ++ str);
			return str;
		});
        return result;
    }
    
    // 打印出语句中的关键词
    getKeywords = function(line) {
        // python 和 aardio 的关键字都算, !pattern 是边界断言, `!\w(xxx)\W` 表示以单词字母开始,且以非单词字符结束
        var pattern = `!\w(<and>|<as>|<assert>|<begin>|<break>|<case>|<catch>|<class>|<continue>|<def>|<del>|<do>|<elif>|<elseif>|<else>|<end>|<except>|<finally>|<for>|<from>|<false>|<False>|<global>|<if>|<import>|<in>|<is>|<lambda>|<nonlocal>|<not>|<None>|<or>|<pass>|<print>|<raise>|<return>|<select>|<this>|<try>|<true>|<True>|<var>|<while>|<with>|<yield>)\W`;
        var list = {};
        for kw in string.gmatch(line, pattern) { 
            ..table.push(list, kw);
        }
        //console.debug(line, '#', string.join(list, ','));
        return list;
    }
    
    // 句尾加分号
    addSemicolon = function(line) {
    	var keywords = this.getKeywords(line);
    	// 若第一个关键字不是这些语句, 则加上分号
    	//TODO: 去掉注释, 找到真实的句尾
        if(#keywords == 0 or !..table.find({'begin','def','class','while','function','for','if','else','elif','elseif','except','try','catch','finally','select','case','with'}, keywords[1])) 
        	line = line ++ ';';
       	return line;
    }
    
    //逐行替换
    replaceByLines = function(src) {
        var result, err;
        var lines = string.split(src, '\n');
		var newLines = {};
		var prevIndent, newIndent = 0, 0;	//当前的缩进量(空格数量)
		var prevCodeLine = 0;	//前一有效代码行(非空行)的行号
		var emptyLine = false;
		for(i, line in lines) {
			// 处理单行注释
        	var newLine = this.replaceSingleLineComment(line);	// '#' => '//'
        	emptyLine = this.isEmptyLine(newLine);
        	newLine = this.encodeStrLiterals(newLine, true);	// 加密语句中的字符串, 使其中文本无法参与语法分析
        	/***故下面所有的行内内容处理时, 不用担心会匹配到字符串内可能存在的 python 关键字***/
        	if(!emptyLine) {        		
        		// 处理列表的声明性语句 '= [...]' (不包括其它[])
        		newLine = this.replaceList(newLine);
        		// 处理 if|elif|while等带控制语句
        		newLine = this.replaceColonStmt(newLine);
        		// 处理修饰符
        		newLine = this.replaceDecorator(newLine);
        		// 处理class (parent): 带有继承的类 
        		newLine = this.replaceClass(newLine);
        		// 处理 lambda 表达式
        		newLine = this.replaceLambda(newLine);
        		// 处理 except 和 finally 子句
        		newLine = this.replaceExceptFinally(newLine, i);
        		// 处理 转换 self->this, except->catch 之类的其它保留字
        		newLine = this.replaceReservedWords(newLine);
        		// 处理 Unicode 字符串格式 u"..." 和 raw string r"..."
        		newLine = this.replaceUnicodeStr(newLine);
        		// 处理 字符串格式化 '...' % (...)
        		newLine = this.replaceStrFormat(newLine);
        		// TODO: 处理列表推导式: [x for x in range(10) if x % 2 == 0 else...]
        		//newLine = this.replaceListComprehension(newLine);
        		// TODO: 处理列表的 hasattr, getattr, setattr 等 attr 函数
        		//newLine = this.replaceAttrFunc(newLine);
        	}
        	// 处理缩进, 附加返回newIndent-新的缩进, brackets-附加的花括号内容
        	newLine, prevIndent, brackets = this.replaceIndents(i, newLine, prevIndent, emptyLine);
        	//若有需要补充的花括号, 则先插入之
        	if(brackets) {
        		..table.insert(newLines, brackets, prevCodeLine);
        	}
        	newLine = string.trimright(newLine);
        	newLine = this.encodeStrLiterals(newLine, false);	// 还原语句中的字符串
        	// 句末加分号
        	if(!emptyLine and $_config.addSemicolon) {
        		newLine = this.addSemicolon(newLine);
        	}
        	..table.push(newLines, newLine);
        	//若非空行, 则更新"最近的代码行号", 用于后续花括号插入时定位
        	if(!emptyLine) {
        		prevCodeLine = #newLines + 1;
        	}
       	}
       	
       	//若到了末尾还有缩进, 则补全回缩右花括号'}'
       	newLines = ..table.concat(newLines, this.eofIndents(prevIndent));
       	result = string.join(newLines, '\r\n');
    	return result, err;
    }

    // 处理列表声明 '[...]'
    replaceList = function(line) {
        var pattern = `([\=])\s*\[(.*?)\]`;
        var result = string.replace(line, pattern, `\1 {\2}`);  //若要用 \1 代表匹配,不能用单引号; 在单引号里 \1 代表ascii(0x1)
        return result;
    }
    
    // 处理 except 和 finally 子句
    replaceExceptFinally = function(line, i) {
        /**行内的字符串文本已经预先加密, 不用担心会在字符串中匹配到关键字的情况**/
        var pattern = `^( *)(<except>|<finally>)\s*([\(\)\w\s]*?)\s*(\:)`;
        var found = false
        var result = string.replace(line, pattern, function($1, $2, $3, $4) {
            //owner = 原始字符串
            found = true;
            var res = $2;	// except 或 finally
            //console.debug('#line:'++i, ', #1: ', $1, $2, $3, $4);
            if($2 == 'finally') {
                res = '/*' ++ $2 ++ '*/';	// aardio 没有 finally, 故把它注释掉
            } elseif($2 == 'except') {  // and #$3 > 0 $2 有内容,即类似"Exception as e:"
            	//console.debug('#line:'++i++', #2: $2="'++$2++'", $3="'++$3++'"', ', $4="'++$4++'"');
            	if(#$3 == 0) {
            		res = $2 ++ '(e)';
            	} else {
                	res = $2 ++ string.replace($3, `(\w+\s+as\s+)`, `/*\1*/`); //若要用 \1 代表匹配,不能用单引号; 在单引号里 \1 代表ascii(0x1)
                }
                //console.debug('#line:'++i++', #3: res="'++res++'"');
            }
            res = $1 ++ res ++ $4; // 最后要把 ':' 加上,以利于后续产生左花括号'{'
            //console.debug('#line:'++i, ', #4: res='++res);
            return res;
        });
        /*// debug
        if(found) {
            var str = line ++ result;
            string.save('./log/debug-line-'++i++'.tmp.txt', str);
        }
        */
        
        return result;
    }
    
    // 处理 self|except 之类的保留字
    replaceReservedWords = function(line) {
        var pattern = `!\w(<self>|<except>|<pass>|<raise>|<len>|<None>|<True>|<False>|<is not>|<is>)(\W)`;
        var result = string.replace(line, pattern, function($1, $2) {
            //console.debug($1, $2);
            var map = {
                ['self'] = 'this',		//key 名必须用方括号
                ['except'] = 'catch',
                ['pass'] = '// pass',	// 空语句
                ['raise'] = 'error',
                ['len'] = '#',
                ['None'] = 'null',
                ['True'] = 'true',
                ['False'] = 'false',
                ['is not'] = '!=',		// 注:实际上 python 的 is/is not 与 ==/!= 含义有所不同: is 比较引用相等, 而 == 比较值相等;
                ['is'] = '=='			// 但是 aardio 没有对应的操作符, 故暂且用 ==/!=
            };
            
            var $1m = map[$1];
            return $1m + $2;
        }); 
        return result;
    }
    // 替换带有继承的类声明: class XXX(parent) 这样的
    replaceClass = function(line) {
        var pattern = `!\w(class)\s+([\w\$]+)\s*\(([\w\$\*\, ]+)\)`; //类的声明
        var result = string.replace(line, pattern, function($1, $2, $3) {
            //console.debug($1, $2, $3);
            var res = $1 ++ ' ' ++ $2;
            if($3 !== 'object') {	//若继承的父类
                var parents = string.split($3, ',');
            	res = res ++ ' {\r\n' ++ core.pad($_config.indentSpaces) ++ 'this = ' ++ parents[1] ++ '(...);';
            	res = res ++ '// 继承的父类 <--请把这行移入类的构造函数 ctor 内!';
            	if(#parents > 1) {
            		//TODO: 要处理继承多个父类的情况, 逗号分隔的
            		// 用 table.mixin 或 table.assign
            	}
            }
            return res;
        }); 
        return result;
    }
    // 替换修饰符 @decorator , 注释掉
    replaceDecorator = function(line) {
        var pattern = `^(\s+)(\@\w+)`;
        var result = string.replace(line, pattern, `\1\/\/ \2`);//若要用 \1 代表匹配,不能用单引号; 在单引号里 \1 代表ascii(0x1)
        return result;
    }
    // 替换 lambda 表达式
    replaceLambda = function(line) {
        var pattern = `([^\a]lambda)\s*([^\r\n\:]*)\s*\:\s*`;
        var result = string.replace(line, pattern, `\1(\2) `);//若要用 \1 代表匹配,不能用单引号; 在单引号里 \1 代表ascii(0x1)
        return result;
    }
    // 替换 Unicode 字符串 u"str" 和 raw字符串 r"reg"
    replaceUnicodeStr = function(line) {
        var pattern = `[ur](['"])(.*?)\1`;
        var result = string.replace(line, pattern, `\1\2\1`);//若要用 \1 代表匹配,不能用单引号; 在单引号里 \1 代表ascii(0x1)
        return result;
    }
    
    // 处理字符串格式化
    replaceStrFormat = function(line) {
        //同时支持 % 和 .format()
        var pattern = `(['"])(.+?)\1\s*(<\%>|<\.format>)\s*\((.+)\)`;
        var result = string.replace(line, pattern, function($1, $2, $3, $4) {
            //并且将参数$4中的格式转换函数替换成aardio的
            var $4m = string.replace($4, `!\w((<str>|<int>|<float>|<hex>|<oct>|<ord>)\s*(\())`, function($1, $2, $3) {
                //$1-整个匹配, $2-格式转换函数, $3-左括号'('
                var map = {
                    ['str'] = 'tostring'++$3;	//$3是左括号'('
                    ['int'] = 'tonumber'++$3;
                    ['float'] = 'tonumber'++$3;
                    ['hex'] = 'string.format'++$3++'"%x",';
                    ['ord'] = 'string.format'++$3++'"%c",';
                    ['oct'] = 'string.format'++$3++'"%o",';
                };
                return map[$2];
            });
            
            //$1-引号, $2-引号内的字符串, $3-'%'或format, $4-格式化参数 
            return `string.format(`++$1++$2++$1++`, `++$4m++`)`;
        });
        return result;
    }
        
    //替换缩进: 发现缩进量 newIndent, 缩进级数level, 是否空行empty, 新的行代码line, 以及附加的补充内容brackets
    //若本行产生了缩进(increase), 则在本行前插入左括号"{"; 
    //若本行产生了回缩(decrease), 则在本行前插入右括号"}"
    replaceIndents = function(i, line, prevIndent, isEmptyLine) {
        var dir;			// 缩进的类型/方向: null=不缩进, increase-缩进, decrease-回缩
        var newIndent = prevIndent;	// 缩进的空格数目
        var level = 0; 		//表示缩进的级数, 4格为一级, 一般用在回缩时
        var brackets;		//需补充的花括号
        var pattern = `^( *)`;	//仅限空格
        var spaces = string.match(line, pattern);	//左侧的空格数
        newIndent = #spaces;	//缩进的空格数目
        //处理缩进空格不对齐的情况: 少1个的补齐1个, 多1个的去除1个
        var  mod = newIndent %  $_config.indentSpaces; //除余取模: 余数为1-多1个, 2-多2个, 3-少1个
        if(mod == 1) {	//多1格, 删去
        	//console.log('[WARNING]line#'++i++' Error Indent Spaces: '++newIndent++', mod='++mod++', src code="'++line++'"');
        	newIndent -= 1;
        	line = string.slice(line, 2); //删去1格, 即:截取从第2个开始到结尾的字符串
        }elseif(mod == 3){	//少1格, 补齐
        	//console.log('[WARNING]line#'++i++' Error Indent Spaces:'++newIndent++', mod='++mod++', src code="'++line++'"');
        	newIndent += 1;
        	line = ' ' ++ line;
        }elseif(mod == 2){	//TODO:多2格或少2格, 不知如何处理?
        	//console.log('[ERROR]line#'++i++' Error Indent Spaces:'++newIndent++', mod='++mod++', src code="'++line++'"');
        }
        
        level = (newIndent - prevIndent) / $_config.indentSpaces;	//缩进的级数(4格为1级)
        
        if(isEmptyLine) {
        	newIndent = prevIndent;	//若是空行则不必改变缩进
        } else {
        	if(newIndent > prevIndent) {
            	dir = 'increase';	// 缩进增加, 需补充'{'
            	brackets = core.pad(prevIndent) ++ '{';
        	} elseif (newIndent < prevIndent) {
        		dir = 'decrease';	// 缩进减少, 需补充'}'(可能有多级)
        		var lines = {};
        		for(l = -1; level; -1) {	//回缩时的 level 是负值
        			var spaces = prevIndent + l * $_config.indentSpaces;
        			..table.push(lines, core.pad(spaces) ++ '}');
        		}
        		brackets = string.join(lines, '\r\n');
        	}
        }
	    //line, newIndent, brackets-需补足的花括号
        return line, newIndent, brackets;
    }
    
    // 整体性的替代
    replaceEntirety = function(src) {
        var result;
        // 变量命名驼峰化
        if($_config.camelize) {
        	src = this.camelize(src);
        }
        // 处理导入
        src = this.replaceFromImports(src);
        // 处理函数
        src = this.replaceFunctions(src);
        // 处理冒号的行
        src = this.replaceColons(src);
        // 处理 else/catch 前的回车换行
        src = this.replaceElses(src);
        // 处理多行注释
        src = this.replaceMultiLineComments(src);
        // 恢复多行的回车换行符(这个必须放在最后面)
        result = this.restoreMultilineText(src);
        return result;
    }
    
    // 处理以冒号结尾的 "if|for|while ... :" 的语句, 为语句体加上括号()
    replaceColonStmt = function(line) {
        var pattern = `!\w(<if>|<with>|<elif>|<while>|<for>|<except>)\s+(.+?)\s*[\:]`;	//此时还没处理掉冒号
        var result = string.replace(line, pattern, `\1 (\2) :`);//若要用 \1 代表匹配,不能用单引号; 在单引号里 \1 代表ascii(0x1)
        return result;
    }
    // 处理 else/catch 前置换行(即: }\r\nelse )的情况
    replaceElses = function(src) {
        var pattern = `\}\s+(<else>|<catch>)`; //把包含回车换行的连续多个空白符, 都替换成一个空格
        var result = string.replace(src, pattern, `} \1`);//若要用 \1 代表匹配,不能用单引号; 在单引号里 \1 代表ascii(0x1)
        return result;
    }
    
    // 处理冒号+换行+{的情况
    replaceColons = function(src) {
        var pattern = `\s*\:\s+\{`;
        var result = string.replace(src, pattern, ` {`);
        return result;
    }

    // 产生 python 源文件末尾可能存在的缩进回缩
    eofIndents = function(indent) {
        // 每4空格缩进一级
        var result = {};
        if(indent > 0) {
            var step = -1 * $_config.indentSpaces;
            for(i = indent - $_config.indentSpaces; 0; step) {
                var spaces = i;
        		var str = core.pad(spaces) ++ '}';
                ..table.push(result, str);
            }
        }
        return result;
    }
    // 替换单行注释
    replaceSingleLineComment = function(line) {
        var pattern = `(\#(.+?))(\s*)$`;
        var result = line;
        var i, j, v1, v2, v3 = string.find(line, pattern);
        //i,j -匹配的起始和结束位置, v1...v3 - 各匹配项
        if(i) {
            if(!this.isInString(line, i)) {
        		var left = string.left(line, i - 1);
        		result = left ++ '//' ++ v2;	//v1 带#, v2 不带#
        		if(!$_config.trimRight) result = result ++ v3;	//若不除末尾空白则加上
        		result = result ++ '\r';	//必须加上\r\n
        	}
        	//console.debug("new line="++result);        	
        }
        
        return result;
    }
    
    //判断位置(i)是否位于行内的字符串中
    isInString = function(line, i) {
        var result;
        var patterns = {`'([^']+?)'`; `"([^"]+?)"`}; //两种引号都要匹配一次
        // 或合并成一个: (['"])([^\1]+?)(\1)
        for(n, pattern in patterns) {
        	var b, e, v1, v2 = string.find(line, pattern);
        	result = (b <= i) and (i <= e); // i 处于 b和 e 之间
        	if(result) break;
       	}
        return result;
    }
    
    // 替换多行注释
    replaceMultiLineComments = function(src) {
        var pattern = `(<'''>|<""">)([\s\S]+?)(\1)`;	//多行注释, 匹配两种引号
        var result = string.replace(src, pattern, function($1, $2, $3) {
            // 这里先不把先前临时替换的回车换行符给恢复回来, 留作后续
        	var str = `/*` ++ $2 ++ `*/`;
        	return str;
       	}); 
        return result;
    }
    
    // 恢复写成多行的列表[]/元组()/字典{}/函数参数()等
    restoreMultilineText = function(src) {
        var result = string.replace(src, '\x1a', '\n');
        return result;
    }
    
    // 替换变量命名方式
    camelize = function(src) {
        var pattern = `([a-z\d\$])_([a-z])`; //以下划线'_'连接的小写字母变量名
        var result = string.replace(src, pattern, function($1, $2) {
            //owner = 原始字符串
            return $1 ++ string.upper($2); // sys_log -> sysLog
        });
        return result;
    }
    // 替换导入 from...import
    replaceFromImports = function(src) {
        var pattern = `from\s+([\w\.]+?)\s+import\s+([^\r;\:]+)`;	// imports
        var result = string.replace(src, pattern, function($1, $2){
            var res = 'import ' ++ $1 ++ ';' //'import a.b;
            if($2 != '*') {
            	// 分析多个导入变量, 转换成: var a, b = xx.a, xx.b;
            	var list = string.split($2, ',');
            	var vars = {};
            	for(i, v in list) {
                	..table.push(vars, $1 ++ '.' ++ string.trim(v)); // xxx.v; 
            	}
            	if(#vars) {
            		res = res ++ ' var ' ++ $2 ++ ' = ' ++ string.join(vars, ', ');
            	}
            }
            //res = res ++ '\r\n';
            return res;
        }); 
        return result;
    }
    // 替换函数
    replaceFunctions = function(src) {
        var pattern = `!\wdef\s+([\w\$]+)\s*\((.*?)\)\s*(\:)`;
        var result = string.replace(src, pattern, function($1, $2, $3){
            $2 = string.trim($2);
            $2 = string.replace($2, `^(<self>|<this>)[\s\,]*`, ''); //去除 self,
            var res = $1 ++ ' = function(' ++ $2 ++ ')' ++ $3;
            res = string.replace(res, `__init__\s*=\s*function\s*`, 'ctor');	//类的构造函数
            res = string.replace(res, `__del__\s*=\s*function\s*`, 'destructor');	//类的析构函数
            res = string.replace(res, `__str__\s*=\s*function\s*`, '_tostring');	//类的 tostring
            return res;
        }); 
        return result;
    }
}

namespace converter {
    // 导入类里用到的库
    import console;
    import string;
	import core;
	import math;
	import debug;
};